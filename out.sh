#!/bin/bash
#
# Bash version 4.4+ required!
# This code is auto generated by bashc, do not make manual changes
# -----------------------------------------------------------------
# Initialize array counter
_array_uid_=1

# Initialize class object counter
_object_uid_=1
declare -A _object_

############# BASH FUNCTIONS ##############
# Create array
function _bash_createArray() {
    declare -n _return_=${1}
    declare -g -A "_array_${_array_uid_}"
    _return_=${_array_uid_}
    _array_uid_=$(( ${_array_uid_} + 1 ))
}
# Convert strings into char array
function _bash_StrToCharArray() {
    declare string="${1}"
    declare -n _return_=${2}
    _bash_createArray _tmp_return_
    _return_=${_tmp_return_}
    declare index=0
    declare -n indexValue="_array_${_return_}"
    while (( ${index} < ${#string} )); do
        indexValue[${index}]=${string:${index}:1}
        index=$(( ${index} + 1 ))
    done
}
###########################################

# Create function
function _f_main() {
    declare _args_counter_=1

    # Create argument
    declare _f_main_p_argc="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Create argument
    declare _f_main_p_argv="${2}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # If statement
    declare -n _result_0=_f_main_p_argc
    declare _expression_0=$(( ${_result_0:-0} < 2 ))
    declare _f_main_if__lock=0
    if (( ${_expression_0:-0} )); then
    _f_main_if__lock=1

        # Evaluate expression
        # String literal
        declare _expression_1
        _bash_StrToCharArray "Please enter your name as an argument: (e.g. bashc \"John\")" _tmp_return_
        _expression_1=${_tmp_return_}
        _f_exception "${_expression_1:-0}"
    fi

    # Create variable
    declare _f_main_v_name=0

    # Initialize variable
    declare -n _result_1=_f_main_v_name
    declare -n _result_2=_f_main_p_argv
    declare -n _array_expr_0="_array_${_result_2}[1]"
    declare _result_3
    _c_String_f_String "${_array_expr_0:-0}" $(( _object_uid_++ )) _tmp_return_
    _result_3=${_tmp_return_}
    _result_1=${_result_3:-0}
    declare _expression_2="${_result_1:-0}"

    # Evaluate expression
    # String literal
    declare _expression_3
    _bash_StrToCharArray "Hi, " _tmp_return_
    _expression_3=${_tmp_return_}
    declare _result_4
    _c_String_f_String "${_expression_3:-0}" $(( _object_uid_++ )) _tmp_return_
    _result_4=${_tmp_return_}
    declare -n _result_5=_f_main_v_name
    declare _result_6
    _c_String_f_append "${_result_5:-0}" ${_result_4} _tmp_return_
    _result_6=${_tmp_return_}
    _f_printsln "${_result_6:-0}"

    # Evaluate expression
    # String literal
    declare _expression_4
    _bash_StrToCharArray "Let's do some examples ..." _tmp_return_
    _expression_4=${_tmp_return_}
    _f_printcsln "${_expression_4:-0}"

    # If statement
    # String literal
    declare _expression_5
    _bash_StrToCharArray "Want to do 'List' example?" _tmp_return_
    _expression_5=${_tmp_return_}
    declare _result_7
    _f_confirm "${_expression_5:-0}" _tmp_return_
    _result_7=${_tmp_return_}
    declare _f_main_if__lock=0
    if (( ${_result_7:-0} )); then
    _f_main_if__lock=1

        # Evaluate expression
        # String literal
        declare _expression_6
        _bash_StrToCharArray "Add items to a list. Type exit to stop." _tmp_return_
        _expression_6=${_tmp_return_}
        _f_printcsln "${_expression_6:-0}"

        # Create variable
        declare _f_main_if__v_list=0

        # Initialize variable
        declare -n _result_8=_f_main_if__v_list
        declare _result_9
        _c_List_f_List $(( _object_uid_++ )) _tmp_return_
        _result_9=${_tmp_return_}
        _result_8=${_result_9:-0}
        declare _expression_7="${_result_8:-0}"

        # Create variable
        declare _f_main_if__v_exit=0

        # Initialize variable
        declare -n _result_10=_f_main_if__v_exit
        _result_10=0
        declare _expression_8="${_result_10:-0}"

        # While statement
        while true; do
        declare -n _result_11=_f_main_if__v_exit
        declare _expression_9=$(( ${_result_11:-0} ^ 1 ))
        ! (( ${_expression_9:-0} )) && break

            # Create variable
            declare _f_main_if__while__v_word=0

            # Initialize variable
            declare -n _result_12=_f_main_if__while__v_word
            declare _result_13
            _f_readStr _tmp_return_
            _result_13=${_tmp_return_}
            _result_12=${_result_13:-0}
            declare _expression_10="${_result_12:-0}"

            # If statement
            declare -n _result_14=_f_main_if__while__v_word
            # String literal
            declare _expression_11
            _bash_StrToCharArray "exit" _tmp_return_
            _expression_11=${_tmp_return_}
            declare _result_15
            _f_str "${_expression_11:-0}" _tmp_return_
            _result_15=${_tmp_return_}
            declare _result_16
            _c_String_f_equals "${_result_15:-0}" ${_result_14} _tmp_return_
            _result_16=${_tmp_return_}
            declare _f_main_if__while__if__lock=0
            if (( ${_result_16:-0} )); then
            _f_main_if__while__if__lock=1

                # Evaluate expression
                declare -n _result_17=_f_main_if__v_exit
                _result_17=1
                declare _expression_12="${_result_17:-0}"
            fi

            # Else statement
            if ! (( ${_f_main_if__while__if__lock} )); then

                # Evaluate expression
                declare -n _result_18=_f_main_if__v_list
                declare -n _result_19=_f_main_if__while__v_word
                _c_List_f_add "${_result_19:-0}" ${_result_18}
            fi
        done

        # Evaluate expression
        # String literal
        declare _expression_13
        _bash_StrToCharArray "Total number of items added to the list: " _tmp_return_
        _expression_13=${_tmp_return_}
        _f_printcs "${_expression_13:-0}"

        # Evaluate expression
        declare -n _result_20=_f_main_if__v_list
        declare _result_21
        _c_List_f_size ${_result_20} _tmp_return_
        _result_21=${_tmp_return_}
        _f_printiln "${_result_21:-0}"
    fi

    # Else statement
    if ! (( ${_f_main_if__lock} )); then

        # Evaluate expression
        # String literal
        declare _expression_14
        _bash_StrToCharArray "Skipping 'List' example" _tmp_return_
        _expression_14=${_tmp_return_}
        _f_printcsln "${_expression_14:-0}"
    fi

    # If statement
    # String literal
    declare _expression_15
    _bash_StrToCharArray "Want to do 'Casting' example?" _tmp_return_
    _expression_15=${_tmp_return_}
    declare _result_22
    _f_confirm "${_expression_15:-0}" _tmp_return_
    _result_22=${_tmp_return_}
    declare _f_main_if__lock=0
    if (( ${_result_22:-0} )); then
    _f_main_if__lock=1

        # Evaluate expression
        # String literal
        declare _expression_16
        _bash_StrToCharArray "Adding the following two items to a list: 123, \"Orange\"" _tmp_return_
        _expression_16=${_tmp_return_}
        _f_printcsln "${_expression_16:-0}"

        # Create variable
        declare _f_main_if__v_list=0

        # Initialize variable
        declare -n _result_23=_f_main_if__v_list
        declare _result_24
        _c_List_f_List $(( _object_uid_++ )) _tmp_return_
        _result_24=${_tmp_return_}
        _result_23=${_result_24:-0}
        declare _expression_17="${_result_23:-0}"

        # Evaluate expression
        declare -n _result_25=_f_main_if__v_list
        declare _result_26
        _c_Integer_f_Integer "123" $(( _object_uid_++ )) _tmp_return_
        _result_26=${_tmp_return_}
        _c_List_f_add "${_result_26:-0}" ${_result_25}

        # Evaluate expression
        declare -n _result_27=_f_main_if__v_list
        # String literal
        declare _expression_18
        _bash_StrToCharArray "Orange" _tmp_return_
        _expression_18=${_tmp_return_}
        declare _result_28
        _c_String_f_String "${_expression_18:-0}" $(( _object_uid_++ )) _tmp_return_
        _result_28=${_tmp_return_}
        _c_List_f_add "${_result_28:-0}" ${_result_27}

        # Evaluate expression
        # String literal
        declare _expression_19
        _bash_StrToCharArray "Printing items: " _tmp_return_
        _expression_19=${_tmp_return_}
        _f_printcsln "${_expression_19:-0}"

        # Create variable
        declare _f_main_if__v_i=0

        # Create variable
        declare _f_main_if__v_typeString=0

        # Initialize variable
        declare -n _result_29=_f_main_if__v_typeString
        # String literal
        declare _expression_20
        _bash_StrToCharArray "String" _tmp_return_
        _expression_20=${_tmp_return_}
        declare _result_30
        _f_str "${_expression_20:-0}" _tmp_return_
        _result_30=${_tmp_return_}
        _result_29=${_result_30:-0}
        declare _expression_21="${_result_29:-0}"

        # Create variable
        declare _f_main_if__v_typeInteger=0

        # Initialize variable
        declare -n _result_31=_f_main_if__v_typeInteger
        # String literal
        declare _expression_22
        _bash_StrToCharArray "Integer" _tmp_return_
        _expression_22=${_tmp_return_}
        declare _result_32
        _f_str "${_expression_22:-0}" _tmp_return_
        _result_32=${_tmp_return_}
        _result_31=${_result_32:-0}
        declare _expression_23="${_result_31:-0}"

        # For statement
        declare -n _result_33=_f_main_if__v_i
        _result_33=0
        declare _expression_24="${_result_33:-0}"
        while true; do
        declare -n _result_34=_f_main_if__v_i
        declare -n _result_35=_f_main_if__v_list
        declare _result_36
        _c_List_f_size ${_result_35} _tmp_return_
        _result_36=${_tmp_return_}
        declare _expression_25=$(( ${_result_34:-0} < ${_result_36:-0} ))
        ! (( ${_expression_25:-0} )) && break

            # Create variable
            declare _f_main_if__for__v_type=0

            # Initialize variable
            declare -n _result_37=_f_main_if__for__v_type
            declare -n _result_38=_f_main_if__v_list
            declare -n _result_39=_f_main_if__v_i
            declare _result_40
            _c_List_f_get "${_result_39:-0}" ${_result_38} _tmp_return_
            _result_40=${_tmp_return_}
            declare _result_41
            _c_Object_f_type ${_result_40} _tmp_return_
            _result_41=${_tmp_return_}
            _result_37=${_result_41:-0}
            declare _expression_26="${_result_37:-0}"

            # Evaluate expression
            # String literal
            declare _expression_27
            _bash_StrToCharArray "Item at index " _tmp_return_
            _expression_27=${_tmp_return_}
            _f_printcs "${_expression_27:-0}"

            # Evaluate expression
            declare -n _result_42=_f_main_if__v_i
            _f_printi "${_result_42:-0}"

            # If statement
            declare -n _result_43=_f_main_if__for__v_type
            declare -n _result_44=_f_main_if__v_typeString
            declare _result_45
            _c_String_f_equals "${_result_44:-0}" ${_result_43} _tmp_return_
            _result_45=${_tmp_return_}
            declare _f_main_if__for__if__lock=0
            if (( ${_result_45:-0} )); then
            _f_main_if__for__if__lock=1

                # Evaluate expression
                # String literal
                declare _expression_28
                _bash_StrToCharArray " is a String" _tmp_return_
                _expression_28=${_tmp_return_}
                _f_printcsln "${_expression_28:-0}"

                # Create variable
                declare _f_main_if__for__if__v_cast=0

                # Initialize variable
                declare -n _result_46=_f_main_if__for__if__v_cast
                declare -n _result_47=_f_main_if__v_list
                declare -n _result_48=_f_main_if__v_i
                declare _result_49
                _c_List_f_get "${_result_48:-0}" ${_result_47} _tmp_return_
                _result_49=${_tmp_return_}
                _result_46=${_result_49:-0}
                declare _expression_29="${_result_46:-0}"

                # Evaluate expression
                declare -n _result_50=_f_main_if__for__if__v_cast
                _f_printsln "${_result_50:-0}"
            fi

            # Elif statement
            if ! (( ${_f_main_if__for__if__lock} )); then
            declare -n _result_51=_f_main_if__for__v_type
            declare -n _result_52=_f_main_if__v_typeInteger
            declare _result_53
            _c_String_f_equals "${_result_52:-0}" ${_result_51} _tmp_return_
            _result_53=${_tmp_return_}
            if (( ${_result_53:-0} )); then
            _f_main_if__for__if__lock=1

                # Evaluate expression
                # String literal
                declare _expression_30
                _bash_StrToCharArray " is an Integer" _tmp_return_
                _expression_30=${_tmp_return_}
                _f_printcsln "${_expression_30:-0}"

                # Create variable
                declare _f_main_if__for__elif__v_cast=0

                # Initialize variable
                declare -n _result_54=_f_main_if__for__elif__v_cast
                declare -n _result_55=_f_main_if__v_list
                declare -n _result_56=_f_main_if__v_i
                declare _result_57
                _c_List_f_get "${_result_56:-0}" ${_result_55} _tmp_return_
                _result_57=${_tmp_return_}
                _result_54=${_result_57:-0}
                declare _expression_31="${_result_54:-0}"

                # Evaluate expression
                declare -n _result_58=_f_main_if__for__elif__v_cast
                declare _result_59
                _c_Integer_f_getInteger ${_result_58} _tmp_return_
                _result_59=${_tmp_return_}
                _f_printiln "${_result_59:-0}"
            fi
            fi

            # Else statement
            if ! (( ${_f_main_if__for__if__lock} )); then

                # Evaluate expression
                # String literal
                declare _expression_32
                _bash_StrToCharArray "Unknown type!" _tmp_return_
                _expression_32=${_tmp_return_}
                _f_exception "${_expression_32:-0}"
            fi
        declare -n _result_60=_f_main_if__v_i
        declare -n _result_61=_f_main_if__v_i
        declare _expression_33=$(( ${_result_61:-0} + 1 ))
        _result_60=${_expression_33:-0}
        declare _expression_34="${_result_60:-0}"
        done
    fi

    # Else statement
    if ! (( ${_f_main_if__lock} )); then

        # Evaluate expression
        # String literal
        declare _expression_35
        _bash_StrToCharArray "Skipping 'Casting' example" _tmp_return_
        _expression_35=${_tmp_return_}
        _f_printcsln "${_expression_35:-0}"
    fi

    # Evaluate expression
    # String literal
    declare _expression_36
    _bash_StrToCharArray "Congratulations " _tmp_return_
    _expression_36=${_tmp_return_}
    declare _result_62
    _f_str "${_expression_36:-0}" _tmp_return_
    _result_62=${_tmp_return_}
    declare -n _result_63=_f_main_v_name
    declare _result_64
    _c_String_f_append "${_result_63:-0}" ${_result_62} _tmp_return_
    _result_64=${_tmp_return_}
    # String literal
    declare _expression_37
    _bash_StrToCharArray "! You've completed all the examples!" _tmp_return_
    _expression_37=${_tmp_return_}
    declare _result_65
    _f_str "${_expression_37:-0}" _tmp_return_
    _result_65=${_tmp_return_}
    declare _result_66
    _c_String_f_append "${_result_65:-0}" ${_result_64} _tmp_return_
    _result_66=${_tmp_return_}
    _f_printsln "${_result_66:-0}"

    # Evaluate expression
    # String literal
    declare _expression_38
    _bash_StrToCharArray "Thank you for trying BashClass :)" _tmp_return_
    _expression_38=${_tmp_return_}
    _f_printcsln "${_expression_38:-0}"

    # Return statement
    _return_=0
    return
}

# Create function
function _f_confirm() {
    declare _args_counter_=1

    # Create argument
    declare _f_confirm_p_message="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Create variable
    declare _f_confirm_v_yes=0

    # Initialize variable
    declare -n _result_67=_f_confirm_v_yes
    # String literal
    declare _expression_39
    _bash_StrToCharArray "y" _tmp_return_
    _expression_39=${_tmp_return_}
    declare _result_68
    _f_str "${_expression_39:-0}" _tmp_return_
    _result_68=${_tmp_return_}
    _result_67=${_result_68:-0}
    declare _expression_40="${_result_67:-0}"

    # Create variable
    declare _f_confirm_v_YES=0

    # Initialize variable
    declare -n _result_69=_f_confirm_v_YES
    # String literal
    declare _expression_41
    _bash_StrToCharArray "Y" _tmp_return_
    _expression_41=${_tmp_return_}
    declare _result_70
    _f_str "${_expression_41:-0}" _tmp_return_
    _result_70=${_tmp_return_}
    _result_69=${_result_70:-0}
    declare _expression_42="${_result_69:-0}"

    # Evaluate expression
    declare -n _result_71=_f_confirm_p_message
    declare _result_72
    _f_str "${_result_71:-0}" _tmp_return_
    _result_72=${_tmp_return_}
    # String literal
    declare _expression_43
    _bash_StrToCharArray " (y/n)" _tmp_return_
    _expression_43=${_tmp_return_}
    declare _result_73
    _f_str "${_expression_43:-0}" _tmp_return_
    _result_73=${_tmp_return_}
    declare _result_74
    _c_String_f_append "${_result_73:-0}" ${_result_72} _tmp_return_
    _result_74=${_tmp_return_}
    _f_printsln "${_result_74:-0}"

    # Create variable
    declare _f_confirm_v_val=0

    # Initialize variable
    declare -n _result_75=_f_confirm_v_val
    declare _result_76
    _f_readStr _tmp_return_
    _result_76=${_tmp_return_}
    _result_75=${_result_76:-0}
    declare _expression_44="${_result_75:-0}"

    # If statement
    declare -n _result_77=_f_confirm_v_val
    declare -n _result_78=_f_confirm_v_yes
    declare _result_79
    _c_String_f_equals "${_result_78:-0}" ${_result_77} _tmp_return_
    _result_79=${_tmp_return_}
    declare -n _result_80=_f_confirm_v_val
    declare -n _result_81=_f_confirm_v_YES
    declare _result_82
    _c_String_f_equals "${_result_81:-0}" ${_result_80} _tmp_return_
    _result_82=${_tmp_return_}
    declare _expression_45=$(( ${_result_79:-0} || ${_result_82:-0} ))
    declare _f_confirm_if__lock=0
    if (( ${_expression_45:-0} )); then
    _f_confirm_if__lock=1

        # Return statement
        _return_=1
        return
    fi

    # Return statement
    _return_=0
    return
}

# Create function
function _c_Integer_f_Integer() {
    declare _args_counter_=1

    # Create argument with a default value
    if (( 0 < $(( ${#} - 0 )) )); then
    declare _c_Integer_f_Integer_p_data="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))
    else
    declare _c_Integer_f_Integer_p_data=0
    declare -n _result_83=_c_Integer_f_Integer_p_data
    _result_83=0
    declare _expression_46="${_result_83:-0}"
    _c_Integer_f_Integer_p_data=${_expression_46:-0}
    fi

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Declare member
    _object_[${_this_},"_c_Integer_v_data"]=0

    # Header info
    [[ -v _object_[${_this_},"__type__"] ]] || _object_[${_this_},"__type__"]="Integer"
    # Evaluate expression
    declare _result_84
    _c_Object_f_Object ${_this_} _tmp_return_
    _result_84=${_tmp_return_}

    # Evaluate expression
    declare _result_85=${_this_}
    declare -n _result_86=_object_[${_result_85},"_c_Integer_v_data"]
    declare -n _result_87=_c_Integer_f_Integer_p_data
    _result_86=${_result_87:-0}
    declare _expression_47="${_result_86:-0}"

    # Return statement
    _return_=${_this_}
}

# Create function
function _c_Integer_f_setInteger() {
    declare _args_counter_=1

    # Create argument
    declare _c_Integer_f_setInteger_p_data="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Evaluate expression
    declare _result_88=${_this_}
    declare -n _result_89=_object_[${_result_88},"_c_Integer_v_data"]
    declare -n _result_90=_c_Integer_f_setInteger_p_data
    _result_89=${_result_90:-0}
    declare _expression_48="${_result_89:-0}"
}

# Create function
function _c_Integer_f_getInteger() {
    declare _args_counter_=1

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Return statement
    declare -n _result_91=_object_[${_this_},"_c_Integer_v_data"]
    _return_=${_result_91:-0}
    return
}

# Create function
function _c_List_f_List() {
    declare _args_counter_=1

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Declare member
    _object_[${_this_},"_c_List_v_data"]=0

    # Initialize member
    declare -n _result_92=_object_[${_this_},"_c_List_v_data"]
    # New array
    declare _expression_49
    _bash_createArray _tmp_return_
    _expression_49=${_tmp_return_}
    _result_92=${_expression_49:-0}
    declare _expression_50="${_result_92:-0}"

    # Declare member
    _object_[${_this_},"_c_List_v_size"]=0

    # Initialize member
    declare -n _result_93=_object_[${_this_},"_c_List_v_size"]
    _result_93=0
    declare _expression_51="${_result_93:-0}"

    # Header info
    [[ -v _object_[${_this_},"__type__"] ]] || _object_[${_this_},"__type__"]="List"
    # Evaluate expression
    declare _result_94
    _c_Object_f_Object ${_this_} _tmp_return_
    _result_94=${_tmp_return_}

    # Return statement
    _return_=${_this_}
}

# Create function
function _c_List_f_add() {
    declare _args_counter_=1

    # Create argument
    declare _c_List_f_add_p_object="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Evaluate expression
    declare -n _result_95=_object_[${_this_},"_c_List_v_data"]
    declare -n _result_96=_object_[${_this_},"_c_List_v_size"]
    declare -n _array_expr_1="_array_${_result_95}[${_result_96:-0}]"
    declare -n _result_97=_c_List_f_add_p_object
    _array_expr_1=${_result_97:-0}
    declare _expression_52="${_array_expr_1:-0}"

    # Evaluate expression
    declare -n _result_98=_object_[${_this_},"_c_List_v_size"]
    declare -n _result_99=_object_[${_this_},"_c_List_v_size"]
    declare _expression_53=$(( ${_result_99:-0} + 1 ))
    _result_98=${_expression_53:-0}
    declare _expression_54="${_result_98:-0}"
}

# Create function
function _c_List_f_pop() {
    declare _args_counter_=1

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # If statement
    declare -n _result_100=_object_[${_this_},"_c_List_v_size"]
    declare _expression_55=$(( ${_result_100:-0} == 0 ))
    declare _c_List_f_pop_if__lock=0
    if (( ${_expression_55:-0} )); then
    _c_List_f_pop_if__lock=1

        # Evaluate expression
        # String literal
        declare _expression_56
        _bash_StrToCharArray "Cannot remove element from an empty list" _tmp_return_
        _expression_56=${_tmp_return_}
        _f_exception "${_expression_56:-0}"
    fi

    # Evaluate expression
    declare -n _result_101=_object_[${_this_},"_c_List_v_size"]
    declare -n _result_102=_object_[${_this_},"_c_List_v_size"]
    declare _expression_57=$(( ${_result_102:-0} - 1 ))
    _result_101=${_expression_57:-0}
    declare _expression_58="${_result_101:-0}"

    # Evaluate expression
    declare -n _result_103=_object_[${_this_},"_c_List_v_data"]
    declare -n _result_104=_object_[${_this_},"_c_List_v_size"]
    declare -n _array_expr_2="_array_${_result_103}[${_result_104:-0}]"
    _array_expr_2=0
    declare _expression_59="${_array_expr_2:-0}"
}

# Create function
function _c_List_f_size() {
    declare _args_counter_=1

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Return statement
    declare -n _result_105=_object_[${_this_},"_c_List_v_size"]
    _return_=${_result_105:-0}
    return
}

# Create function
function _c_List_f_get() {
    declare _args_counter_=1

    # Create argument
    declare _c_List_f_get_p_index="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # If statement
    declare -n _result_106=_c_List_f_get_p_index
    declare _expression_60=$(( ${_result_106:-0} < 0 ))
    declare -n _result_107=_c_List_f_get_p_index
    declare -n _result_108=_object_[${_this_},"_c_List_v_size"]
    declare _expression_61=$(( ${_result_107:-0} >= ${_result_108:-0} ))
    declare _expression_62=$(( ${_expression_60:-0} || ${_expression_61:-0} ))
    declare _c_List_f_get_if__lock=0
    if (( ${_expression_62:-0} )); then
    _c_List_f_get_if__lock=1

        # Evaluate expression
        # String literal
        declare _expression_63
        _bash_StrToCharArray "Cannot access element out of bound" _tmp_return_
        _expression_63=${_tmp_return_}
        _f_exception "${_expression_63:-0}"
    fi

    # Return statement
    declare -n _result_109=_object_[${_this_},"_c_List_v_data"]
    declare -n _result_110=_c_List_f_get_p_index
    declare -n _array_expr_3="_array_${_result_109}[${_result_110:-0}]"
    _return_=${_array_expr_3:-0}
    return
}

# Create function
function _c_Object_f_Object() {
    declare _args_counter_=1

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Header info
    [[ -v _object_[${_this_},"__type__"] ]] || _object_[${_this_},"__type__"]="Object"
    # Return statement
    _return_=${_this_}
}

# Create function
function _c_Object_f_type() {
    declare _args_counter_=1

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Return statement
    # String literal (sub shell)
    declare _expression_64
    _bash_StrToCharArray "$( echo ${_object_[${_this_},"__type__"]} )" _tmp_return_
    _expression_64=${_tmp_return_}
    declare _result_111
    _c_String_f_String "${_expression_64:-0}" $(( _object_uid_++ )) _tmp_return_
    _result_111=${_tmp_return_}
    _return_=${_result_111:-0}
    return
}

# Create function
function _c_String_f_String() {
    declare _args_counter_=1

    # Create argument
    declare _c_String_f_String_p_data="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Declare member
    _object_[${_this_},"_c_String_v_data"]=0

    # Header info
    [[ -v _object_[${_this_},"__type__"] ]] || _object_[${_this_},"__type__"]="String"
    # Evaluate expression
    declare _result_112
    _c_Object_f_Object ${_this_} _tmp_return_
    _result_112=${_tmp_return_}

    # Evaluate expression
    declare _result_113=${_this_}
    declare -n _result_114=_object_[${_result_113},"_c_String_v_data"]
    declare -n _result_115=_c_String_f_String_p_data
    _result_114=${_result_115:-0}
    declare _expression_65="${_result_114:-0}"

    # Return statement
    _return_=${_this_}
}

# Create function
function _c_String_f_length() {
    declare _args_counter_=1

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Run BASH code
     declare -n _l_array_="_array_${_object_[${_this_},_c_String_v_data]}"

    # Return statement
    _return_=$(  echo ${#_l_array_[@]} )
    return
}

# Create function
function _c_String_f_charAt() {
    declare _args_counter_=1

    # Create argument
    declare _c_String_f_charAt_p_index="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # If statement
    declare -n _result_116=_c_String_f_charAt_p_index
    declare _expression_66=$(( ${_result_116:-0} < 0 ))
    declare -n _result_117=_c_String_f_charAt_p_index
    declare _result_118
    _c_String_f_length ${_this_} _tmp_return_
    _result_118=${_tmp_return_}
    declare _expression_67=$(( ${_result_117:-0} >= ${_result_118:-0} ))
    declare _expression_68=$(( ${_expression_66:-0} || ${_expression_67:-0} ))
    declare _c_String_f_charAt_if__lock=0
    if (( ${_expression_68:-0} )); then
    _c_String_f_charAt_if__lock=1

        # Evaluate expression
        # String literal
        declare _expression_69
        _bash_StrToCharArray "Cannot access index out of bound" _tmp_return_
        _expression_69=${_tmp_return_}
        _f_exception "${_expression_69:-0}"
    fi

    # Return statement
    declare -n _result_119=_object_[${_this_},"_c_String_v_data"]
    declare -n _result_120=_c_String_f_charAt_p_index
    declare -n _array_expr_4="_array_${_result_119}[${_result_120:-0}]"
    _return_=${_array_expr_4:-0}
    return
}

# Create function
function _c_String_f_substr() {
    declare _args_counter_=1

    # Create argument
    declare _c_String_f_substr_p_fromIndex="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Create argument
    declare _c_String_f_substr_p_len="${2}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # If statement
    declare -n _result_121=_c_String_f_substr_p_fromIndex
    declare _expression_70=$(( ${_result_121:-0} < 0 ))
    declare _c_String_f_substr_if__lock=0
    if (( ${_expression_70:-0} )); then
    _c_String_f_substr_if__lock=1

        # Evaluate expression
        # String literal
        declare _expression_71
        _bash_StrToCharArray "Substring cannot start from a negative index" _tmp_return_
        _expression_71=${_tmp_return_}
        _f_exception "${_expression_71:-0}"
    fi

    # If statement
    declare -n _result_122=_c_String_f_substr_p_len
    declare _expression_72=$(( ${_result_122:-0} < 0 ))
    declare _c_String_f_substr_if__lock=0
    if (( ${_expression_72:-0} )); then
    _c_String_f_substr_if__lock=1

        # Evaluate expression
        # String literal
        declare _expression_73
        _bash_StrToCharArray "Substring length cannot be negative" _tmp_return_
        _expression_73=${_tmp_return_}
        _f_exception "${_expression_73:-0}"
    fi

    # If statement
    declare -n _result_123=_c_String_f_substr_p_fromIndex
    declare -n _result_124=_c_String_f_substr_p_len
    declare _expression_74=$(( ${_result_123:-0} + ${_result_124:-0} ))
    declare _result_125
    _c_String_f_length ${_this_} _tmp_return_
    _result_125=${_tmp_return_}
    declare _expression_75=$(( ${_expression_74:-0} > ${_result_125:-0} ))
    declare _c_String_f_substr_if__lock=0
    if (( ${_expression_75:-0} )); then
    _c_String_f_substr_if__lock=1

        # Evaluate expression
        # String literal
        declare _expression_76
        _bash_StrToCharArray "Substring index out of bound" _tmp_return_
        _expression_76=${_tmp_return_}
        _f_exception "${_expression_76:-0}"
    fi

    # Create variable
    declare _c_String_f_substr_v_subArray=0

    # Initialize variable
    declare -n _result_126=_c_String_f_substr_v_subArray
    # New array
    declare _expression_77
    _bash_createArray _tmp_return_
    _expression_77=${_tmp_return_}
    _result_126=${_expression_77:-0}
    declare _expression_78="${_result_126:-0}"

    # Create variable
    declare _c_String_f_substr_v_i=0

    # Create variable
    declare _c_String_f_substr_v_si=0

    # Initialize variable
    declare -n _result_127=_c_String_f_substr_v_si
    _result_127=0
    declare _expression_79="${_result_127:-0}"

    # For statement
    declare -n _result_128=_c_String_f_substr_v_i
    declare -n _result_129=_c_String_f_substr_p_fromIndex
    _result_128=${_result_129:-0}
    declare _expression_80="${_result_128:-0}"
    while true; do
    declare -n _result_130=_c_String_f_substr_v_i
    declare -n _result_131=_c_String_f_substr_p_fromIndex
    declare -n _result_132=_c_String_f_substr_p_len
    declare _expression_81=$(( ${_result_131:-0} + ${_result_132:-0} ))
    declare _expression_82=$(( ${_result_130:-0} < ${_expression_81:-0} ))
    ! (( ${_expression_82:-0} )) && break

        # Evaluate expression
        declare -n _result_133=_c_String_f_substr_v_subArray
        declare -n _result_134=_c_String_f_substr_v_si
        declare -n _array_expr_5="_array_${_result_133}[${_result_134:-0}]"
        declare -n _result_135=_object_[${_this_},"_c_String_v_data"]
        declare -n _result_136=_c_String_f_substr_v_i
        declare -n _array_expr_6="_array_${_result_135}[${_result_136:-0}]"
        _array_expr_5=${_array_expr_6:-0}
        declare _expression_83="${_array_expr_5:-0}"

        # Evaluate expression
        declare -n _result_137=_c_String_f_substr_v_si
        declare -n _result_138=_c_String_f_substr_v_si
        declare _expression_84=$(( ${_result_138:-0} + 1 ))
        _result_137=${_expression_84:-0}
        declare _expression_85="${_result_137:-0}"
    declare -n _result_139=_c_String_f_substr_v_i
    declare -n _result_140=_c_String_f_substr_v_i
    declare _expression_86=$(( ${_result_140:-0} + 1 ))
    _result_139=${_expression_86:-0}
    declare _expression_87="${_result_139:-0}"
    done

    # Return statement
    declare -n _result_141=_c_String_f_substr_v_subArray
    declare _result_142
    _c_String_f_String "${_result_141:-0}" $(( _object_uid_++ )) _tmp_return_
    _result_142=${_tmp_return_}
    _return_=${_result_142:-0}
    return
}

# Create function
function _c_String_f_append() {
    declare _args_counter_=1

    # Create argument
    declare _c_String_f_append_p_str="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Create variable
    declare _c_String_f_append_v_newArray=0

    # Initialize variable
    declare -n _result_143=_c_String_f_append_v_newArray
    # New array
    declare _expression_88
    _bash_createArray _tmp_return_
    _expression_88=${_tmp_return_}
    _result_143=${_expression_88:-0}
    declare _expression_89="${_result_143:-0}"

    # Create variable
    declare _c_String_f_append_v_i=0

    # Create variable
    declare _c_String_f_append_v_ni=0

    # Initialize variable
    declare -n _result_144=_c_String_f_append_v_ni
    _result_144=0
    declare _expression_90="${_result_144:-0}"

    # For statement
    declare -n _result_145=_c_String_f_append_v_i
    _result_145=0
    declare _expression_91="${_result_145:-0}"
    while true; do
    declare -n _result_146=_c_String_f_append_v_i
    declare _result_147
    _c_String_f_length ${_this_} _tmp_return_
    _result_147=${_tmp_return_}
    declare _expression_92=$(( ${_result_146:-0} < ${_result_147:-0} ))
    ! (( ${_expression_92:-0} )) && break

        # Evaluate expression
        declare -n _result_148=_c_String_f_append_v_newArray
        declare -n _result_149=_c_String_f_append_v_ni
        declare -n _array_expr_7="_array_${_result_148}[${_result_149:-0}]"
        declare -n _result_150=_c_String_f_append_v_i
        declare _result_151
        _c_String_f_charAt "${_result_150:-0}" ${_this_} _tmp_return_
        _result_151=${_tmp_return_}
        _array_expr_7=${_result_151:-0}
        declare _expression_93="${_array_expr_7:-0}"

        # Evaluate expression
        declare -n _result_152=_c_String_f_append_v_ni
        declare -n _result_153=_c_String_f_append_v_ni
        declare _expression_94=$(( ${_result_153:-0} + 1 ))
        _result_152=${_expression_94:-0}
        declare _expression_95="${_result_152:-0}"
    declare -n _result_154=_c_String_f_append_v_i
    declare -n _result_155=_c_String_f_append_v_i
    declare _expression_96=$(( ${_result_155:-0} + 1 ))
    _result_154=${_expression_96:-0}
    declare _expression_97="${_result_154:-0}"
    done

    # For statement
    declare -n _result_156=_c_String_f_append_v_i
    _result_156=0
    declare _expression_98="${_result_156:-0}"
    while true; do
    declare -n _result_157=_c_String_f_append_v_i
    declare -n _result_158=_c_String_f_append_p_str
    declare _result_159
    _c_String_f_length ${_result_158} _tmp_return_
    _result_159=${_tmp_return_}
    declare _expression_99=$(( ${_result_157:-0} < ${_result_159:-0} ))
    ! (( ${_expression_99:-0} )) && break

        # Evaluate expression
        declare -n _result_160=_c_String_f_append_v_newArray
        declare -n _result_161=_c_String_f_append_v_ni
        declare -n _array_expr_8="_array_${_result_160}[${_result_161:-0}]"
        declare -n _result_162=_c_String_f_append_p_str
        declare -n _result_163=_c_String_f_append_v_i
        declare _result_164
        _c_String_f_charAt "${_result_163:-0}" ${_result_162} _tmp_return_
        _result_164=${_tmp_return_}
        _array_expr_8=${_result_164:-0}
        declare _expression_100="${_array_expr_8:-0}"

        # Evaluate expression
        declare -n _result_165=_c_String_f_append_v_ni
        declare -n _result_166=_c_String_f_append_v_ni
        declare _expression_101=$(( ${_result_166:-0} + 1 ))
        _result_165=${_expression_101:-0}
        declare _expression_102="${_result_165:-0}"
    declare -n _result_167=_c_String_f_append_v_i
    declare -n _result_168=_c_String_f_append_v_i
    declare _expression_103=$(( ${_result_168:-0} + 1 ))
    _result_167=${_expression_103:-0}
    declare _expression_104="${_result_167:-0}"
    done

    # Return statement
    declare -n _result_169=_c_String_f_append_v_newArray
    declare _result_170
    _c_String_f_String "${_result_169:-0}" $(( _object_uid_++ )) _tmp_return_
    _result_170=${_tmp_return_}
    _return_=${_result_170:-0}
    return
}

# Create function
function _c_String_f_equals() {
    declare _args_counter_=1

    # Create argument
    declare _c_String_f_equals_p_str="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # If statement
    declare _result_171
    _c_String_f_length ${_this_} _tmp_return_
    _result_171=${_tmp_return_}
    declare -n _result_172=_c_String_f_equals_p_str
    declare _result_173
    _c_String_f_length ${_result_172} _tmp_return_
    _result_173=${_tmp_return_}
    declare _expression_105=$(( ${_result_171:-0} != ${_result_173:-0} ))
    declare _c_String_f_equals_if__lock=0
    if (( ${_expression_105:-0} )); then
    _c_String_f_equals_if__lock=1

        # Return statement
        _return_=0
        return
    fi

    # Create variable
    declare _c_String_f_equals_v_i=0

    # Initialize variable
    declare -n _result_174=_c_String_f_equals_v_i
    _result_174=0
    declare _expression_106="${_result_174:-0}"

    # While statement
    while true; do
    declare -n _result_175=_c_String_f_equals_v_i
    declare _result_176
    _c_String_f_length ${_this_} _tmp_return_
    _result_176=${_tmp_return_}
    declare _expression_107=$(( ${_result_175:-0} < ${_result_176:-0} ))
    ! (( ${_expression_107:-0} )) && break

        # If statement
        declare -n _result_177=_c_String_f_equals_v_i
        declare _result_178
        _c_String_f_charAt "${_result_177:-0}" ${_this_} _tmp_return_
        _result_178=${_tmp_return_}
        declare -n _result_179=_c_String_f_equals_p_str
        declare -n _result_180=_c_String_f_equals_v_i
        declare _result_181
        _c_String_f_charAt "${_result_180:-0}" ${_result_179} _tmp_return_
        _result_181=${_tmp_return_}
        declare _expression_108=$([[ ${_result_178:-0} != ${_result_181:-0} ]] && echo 1 || echo 0)
        declare _c_String_f_equals_while__if__lock=0
        if (( ${_expression_108:-0} )); then
        _c_String_f_equals_while__if__lock=1

            # Return statement
            _return_=0
            return
        fi

        # Evaluate expression
        declare -n _result_182=_c_String_f_equals_v_i
        declare -n _result_183=_c_String_f_equals_v_i
        declare _expression_109=$(( ${_result_183:-0} + 1 ))
        _result_182=${_expression_109:-0}
        declare _expression_110="${_result_182:-0}"
    done

    # Return statement
    _return_=1
    return
}

# Create function
function _f_printi() {
    declare _args_counter_=1

    # Create argument
    declare _f_printi_p_data="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Run BASH code
     echo -n -e "$1"
}

# Create function
function _f_printiln() {
    declare _args_counter_=1

    # Create argument
    declare _f_printiln_p_data="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Evaluate expression
    declare -n _result_184=_f_printiln_p_data
    _f_printi "${_result_184:-0}"

    # Run BASH code
     echo ""
}

# Create function
function _f_printc() {
    declare _args_counter_=1

    # Create argument
    declare _f_printc_p_data="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Run BASH code
     echo -n -e "$1"
}

# Create function
function _f_printcln() {
    declare _args_counter_=1

    # Create argument
    declare _f_printcln_p_data="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Evaluate expression
    declare -n _result_185=_f_printcln_p_data
    _f_printc "${_result_185:-0}"

    # Run BASH code
     echo ""
}

# Create function
function _f_prints() {
    declare _args_counter_=1

    # Create argument
    declare _f_prints_p_str="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Create variable
    declare _f_prints_v_i=0

    # Initialize variable
    declare -n _result_186=_f_prints_v_i
    _result_186=0
    declare _expression_111="${_result_186:-0}"

    # While statement
    while true; do
    declare -n _result_187=_f_prints_v_i
    declare -n _result_188=_f_prints_p_str
    declare _result_189
    _c_String_f_length ${_result_188} _tmp_return_
    _result_189=${_tmp_return_}
    declare _expression_112=$(( ${_result_187:-0} < ${_result_189:-0} ))
    ! (( ${_expression_112:-0} )) && break

        # Evaluate expression
        declare -n _result_190=_f_prints_p_str
        declare -n _result_191=_f_prints_v_i
        declare _result_192
        _c_String_f_charAt "${_result_191:-0}" ${_result_190} _tmp_return_
        _result_192=${_tmp_return_}
        _f_printc "${_result_192:-0}"

        # Evaluate expression
        declare -n _result_193=_f_prints_v_i
        declare -n _result_194=_f_prints_v_i
        declare _expression_113=$(( ${_result_194:-0} + 1 ))
        _result_193=${_expression_113:-0}
        declare _expression_114="${_result_193:-0}"
    done
}

# Create function
function _f_printsln() {
    declare _args_counter_=1

    # Create argument
    declare _f_printsln_p_str="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Evaluate expression
    declare -n _result_195=_f_printsln_p_str
    _f_prints "${_result_195:-0}"

    # Run BASH code
     echo ""
}

# Create function
function _f_printcs() {
    declare _args_counter_=1

    # Create argument
    declare _f_printcs_p_cstr="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Evaluate expression
    declare -n _result_196=_f_printcs_p_cstr
    declare _result_197
    _c_String_f_String "${_result_196:-0}" $(( _object_uid_++ )) _tmp_return_
    _result_197=${_tmp_return_}
    _f_prints "${_result_197:-0}"
}

# Create function
function _f_printcsln() {
    declare _args_counter_=1

    # Create argument
    declare _f_printcsln_p_cstr="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Evaluate expression
    declare -n _result_198=_f_printcsln_p_cstr
    _f_printcs "${_result_198:-0}"

    # Run BASH code
     echo ""
}

# Create function
function _f_exception() {
    declare _args_counter_=1

    # Create argument
    declare _f_exception_p_message="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Evaluate expression
    declare -n _result_199=_f_exception_p_message
    _f_printcsln "${_result_199:-0}"

    # Run BASH code
     exit 1
}

# Create function
function _f_readStr() {
    declare _args_counter_=1

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Run BASH code
     declare _l_read_

    # Return statement
    # String literal (sub shell)
    declare _expression_115
    _bash_StrToCharArray "$( read _l_read_; echo ${_l_read_} )" _tmp_return_
    _expression_115=${_tmp_return_}
    declare _result_200
    _c_String_f_String "${_expression_115:-0}" $(( _object_uid_++ )) _tmp_return_
    _result_200=${_tmp_return_}
    _return_=${_result_200:-0}
    return
}

# Create function
function _f_str() {
    declare _args_counter_=1

    # Create argument
    declare _f_str_p_message="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Return statement
    declare -n _result_201=_f_str_p_message
    declare _result_202
    _c_String_f_String "${_result_201:-0}" $(( _object_uid_++ )) _tmp_return_
    _result_202=${_tmp_return_}
    _return_=${_result_202:-0}
    return
}

# Convert arguments to char[]
_bash_createArray _main_argv_
_main_argv_index_=0
while (( ${_main_argv_index_} <= ${#@} )); do
    _bash_StrToCharArray "${!_main_argv_index_}" _main_tmp_return_
    declare -n _main_argv_tmp_=_array_${_main_argv_}
    _main_argv_tmp_[${_main_argv_index_}]=${_main_tmp_return_}
    _main_argv_index_=$(( ${_main_argv_index_} + 1 ))
done

# Run main function
_f_main $(( ${#@} + 1 )) ${_main_argv_} _main_return_
exit ${_main_return_}

# -----------------------------------------------------------------
