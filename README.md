# BashClass [![Build Status](https://travis-ci.org/amirbawab/BashClass.svg?branch=master)](https://travis-ci.org/amirbawab/BashClass)

### About
BashClass is a programming language supporting Object Oriented Programming, and compiles into BASH 4.4. Classes and members written in BashClass are converted into associative arrays with unique indices in the generated BASH script. 

BashClass uses EasyCC-C++ library which provides the lexical and syntax analysis. The lexical and syntax analysis configuration files, located under the resources directory, serve as an input to EasyCC-C++ to parse the user files and validate it against a grammar determining the language syntax. 

### Example of BashClass to Bash
#### BashClass
```
class Square {
    var int side;
    constructor Square(var int side=0) {
        this.side = side;
    }

    function int getArea() {
        return side * side;
    }
}

function void print(var int num) {
    ># echo $1
}

function int main() {
    var Square sq = new Square(10);
    print(sq.getArea());
    return 0;
}
```
### BASH 4.4
```
#!/bin/bash
#
# Bash version 4.4+ required!
# This code is auto generated by bashc, do not make manual changes
# -----------------------------------------------------------------
# Initialize array counter
_array_uid_=1

# Initialize class object counter
_object_uid_=1
declare -A _object_

############# BASH FUNCTIONS ##############
# Create array
function _bash_createArray() {
    declare -n _return_=${1}
    declare -g -A "_array_${_array_uid_}"
    _return_=${_array_uid_}
    _array_uid_=$(( ${_array_uid_} + 1 ))
}
# Convert strings into char array
function _bash_StrToCharArray() {
    declare string="${1}"
    declare -n _return_=${2}
    _bash_createArray _tmp_return_
    _return_=${_tmp_return_}
    declare index=0
    declare -n indexValue="_array_${_return_}"
    while (( ${index} < ${#string} )); do
        indexValue[${index}]=${string:${index}:1}
        index=$(( ${index} + 1 ))
    done
}
###########################################

# Create function
function _c_Square_f_Square() {
    declare _args_counter_=1

    # Create argument with a default value
    if (( 0 < $(( ${#} - 0 )) )); then
    declare _c_Square_f_Square_p_side="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))
    else
    declare _c_Square_f_Square_p_side=0
    declare -n _result_0=_c_Square_f_Square_p_side
    _result_0=0
    declare _expression_0="${_result_0:-0}"
    _c_Square_f_Square_p_side=${_expression_0:-0}
    fi

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Declare member
    _object_[${_this_},"_c_Square_v_side"]=0

    # Header info
    [[ -v _object_[${_this_},"__type__"] ]] || _object_[${_this_},"__type__"]="Square"
    # Evaluate expression
    declare _result_1=${_this_}
    declare -n _result_2=_object_[${_result_1},"_c_Square_v_side"]
    declare -n _result_3=_c_Square_f_Square_p_side
    _result_2=${_result_3:-0}
    declare _expression_1="${_result_2:-0}"

    # Return statement
    _return_=${_this_}
}

# Create function
function _c_Square_f_getArea() {
    declare _args_counter_=1

    # Configure 'this'
    declare _this_=${!_args_counter_}
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Return statement
    declare -n _result_4=_object_[${_this_},"_c_Square_v_side"]
    declare -n _result_5=_object_[${_this_},"_c_Square_v_side"]
    declare _expression_2=$(( ${_result_4:-0} * ${_result_5:-0} ))
    _return_=${_expression_2:-0}
    return
}

# Create function
function _f_print() {
    declare _args_counter_=1

    # Create argument
    declare _f_print_p_num="${1}"
    _args_counter_=$(( ${_args_counter_} + 1 ))

    # Run BASH code
     echo $1
}

# Create function
function _f_main() {
    declare _args_counter_=1

    # Configure return statement
    declare -n _return_=${!_args_counter_}

    # Create variable
    declare _f_main_v_sq=0

    # Initialize variable
    declare -n _result_6=_f_main_v_sq
    declare _result_7
    _c_Square_f_Square "10" $(( _object_uid_++ )) _tmp_return_
    _result_7=${_tmp_return_}
    _result_6=${_result_7:-0}
    declare _expression_3="${_result_6:-0}"

    # Evaluate expression
    declare -n _result_8=_f_main_v_sq
    declare _result_9
    _c_Square_f_getArea ${_result_8} _tmp_return_
    _result_9=${_tmp_return_}
    _f_print "${_result_9:-0}"

    # Return statement
    _return_=0
    return
}

# Run main function
_f_main _main_return_
exit ${_main_return_}

# -----------------------------------------------------------------
```

### Build
To build the project:
* Clone project
* Clone submodules: `git submodule update --init --recursive`
* Run `run_cmake.sh`
* Build dev mode: `run_make_dev.sh`
* Build pro mode: `run_make_pro.sh`

### Run
#### Developer mode
```
./bin/bashcdev -s resources/src/lexical_graph.json -c resources/src/lexical_config.json -e resources/src/lexical_errors.json -g resources/src/grammar.json -E resources/src/syntax_errors.json -o /tmp/test.sh -v path/to/file1 path/to/file2 ...
```
#### Production mode
```
./bin/bashc path/to/file1 path/to/file2 ... -o /tmp/test.sh
```
In production mode the list of files to compile can be stored in a file (e.g. `files.list`) and then passed to the application prefixed by an `@` symbol. (e.g. `./bin/bashc @files.list -o /tmp/test.sh`)

### Docker
* Build image: `sudo docker build -t bashclass:latest .`
* Run container: `docker run --name bashclass-tutorial -it bashclass:latest`
* Run the <a href="#example">tutorial example</a>

### Syntax
#### Example
A simple syntax tutorial is provided under the : <a href="example/">example directory</a>.  
To run this tutorial example:
```
cd example/
../bin/bashc @files.list -o /tmp/test.sh
/tmp/test.sh "James"
```

#### Misc
* Function: `function void hello() {}`
* Variable: `var int i = 0`
* Class: `class MyClass{}`
* For loop: `var int i; for(i=0; i < 10; i=i+1){}`
* While loop: `var int i=0; while(i < 10) { i=i+1}`
* If-Elif-Else: `if(i == 1) {} elif (i == 2){} else {}`

### Some features
* Classes
* Global functions
* Class functions
* Global variables
* Class variables
* Type checking
* Comments (inline and block)
* Recursion
* Return primitive types and objects
* While, For and If statements
* Create new instance of objects (e.g. myObj = new Object())
* Constructor is required to create instances
* Run bash code (inline and block)
* Run subshell (e.g. echo $(echo 1) )
* Arrays (1D, 2D, ... ND)
* Casting
* Inheritance
* No function overloading but can define a default value for params
* No polymorphism but can check type at runtime

### Limitations
* The application was tested only on Arch and Ubuntu
* Not much input files has been written to test the application
* Project was created for fun and is not guaranteed to work everywhere, unless users prove the opposite

### Contribution
* Feel free to <a href="CONTRIBUTING.md">contribute</a>

### Additional links
* UML for some classes (check tabs): https://drive.google.com/file/d/0B8fWEFscW3Z4c2pvSHNaSmRiVEE/view?usp=sharing
* Examples of BashClass language syntax: https://github.com/amirbawab/BashClass/tree/master/resources/src/input
* Contributing: https://github.com/amirbawab/BashClass/blob/master/CONTRIBUTING.md
* Code of conduct: https://github.com/amirbawab/BashClass/blob/master/CODE_OF_CONDUCT.md
